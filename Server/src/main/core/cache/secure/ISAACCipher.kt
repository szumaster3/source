package core.cache.secure

/**
 * ISAAC cipher implementation based on Bob Jenkins' original algorithm.
 * See: http://en.wikipedia.org/wiki/ISAAC_(cipher)
 * Source: http://www.burtleburtle.net/bob/java/rand/Rand.java
 *
 * @author Graham Edgecombe
 */
class ISAACCipher(seed: IntArray) {
    /**
     * The count used to track how many random values have been generated.
     */
    private var count = 0

    /**
     * The array to store the generated random values.
     */
    private val results = IntArray(SIZE)

    /**
     * The memory used by the ISAAC algorithm for internal computations.
     */
    private val memory = IntArray(SIZE)

    /**
     * The variable a used in the ISAAC algorithm.
     */
    private var a = 0

    /**
     * The variable b used in the ISAAC algorithm.
     */
    private var b = 0

    /**
     * The variable c used in the ISAAC algorithm.
     */
    private var c = 0

    /**
     * Instantiates a new ISAACCipher with a given seed.
     *
     * @param seed The initial seed array to initialize the cipher.
     * The seed is copied to the results array, and the cipher is initialized.
     */
    init {
        System.arraycopy(seed, 0, results, 0, seed.size)
        init(true)
    }

    val nextValue: Int
        /**
         * Gets the next random value from the ISAAC cipher.
         * If all values have been exhausted, it regenerates the values.
         *
         * @return The next pseudo-random integer generated by the cipher.
         */
        get() {
            if (count-- == 0) {
                isaac()
                count = SIZE - 1
            }
            return 0 // results[count];
        }

    /**
     * Executes the ISAAC algorithm to regenerate the random values in the memory and results arrays.
     * This method is called when the count reaches zero and a new set of random values is needed.
     */
    fun isaac() {
        var x: Int
        var y: Int
        b += ++c
        var i = 0
        var j = SIZE / 2
        while (i < SIZE / 2) {
            // First operation block (shift and add).
            x = memory[i]
            a = a xor (a shl 13)
            a += memory[j++]
            y = memory[(x and MASK) shr 2] + a + b
            memory[i] = y
            b = memory[((y shr SIZE_LOG) and MASK) shr 2] + x
            results[i++] = b

            // Second operation block (shift and add).
            x = memory[i]
            a = a xor (a ushr 6)
            a += memory[j++]
            y = memory[(x and MASK) shr 2] + a + b
            memory[i] = y
            b = memory[((y shr SIZE_LOG) and MASK) shr 2] + x
            results[i++] = b

            // Third operation block (shift and add).
            x = memory[i]
            a = a xor (a shl 2)
            a += memory[j++]
            y = memory[(x and MASK) shr 2] + a + b
            memory[i] = y
            b = memory[((y shr SIZE_LOG) and MASK) shr 2] + x
            results[i++] = b

            // Fourth operation block (shift and add).
            x = memory[i]
            a = a xor (a ushr 16)
            a += memory[j++]
            y = memory[(x and MASK) shr 2] + a + b
            memory[i] = y
            b = memory[((y shr SIZE_LOG) and MASK) shr 2] + x
            results[i++] = b
        }
        // Repeat the operation for remaining memory.
        j = 0
        while (j < SIZE / 2) {
            x = memory[i]
            a = a xor (a shl 13)
            a += memory[j++]
            y = memory[(x and MASK) shr 2] + a + b
            memory[i] = y
            b = memory[((y shr SIZE_LOG) and MASK) shr 2] + x
            results[i++] = b

            x = memory[i]
            a = a xor (a ushr 6)
            a += memory[j++]
            y = memory[(x and MASK) shr 2] + a + b
            memory[i] = y
            b = memory[((y shr SIZE_LOG) and MASK) shr 2] + x
            results[i++] = b

            x = memory[i]
            a = a xor (a shl 2)
            a += memory[j++]
            y = memory[(x and MASK) shr 2] + a + b
            memory[i] = y
            b = memory[((y shr SIZE_LOG) and MASK) shr 2] + x
            results[i++] = b

            x = memory[i]
            a = a xor (a ushr 16)
            a += memory[j++]
            y = memory[(x and MASK) shr 2] + a + b
            memory[i] = y
            b = memory[((y shr SIZE_LOG) and MASK) shr 2] + x
            results[i++] = b
        }
    }

    /**
     * Initializes the ISAAC cipher with a set of initial values.
     * This method performs the core initialization process for the algorithm,
     * which involves several rounds of mixing the seed values into memory.
     *
     * @param flag A boolean flag indicating whether or not the results array should be used for further initialization.
     */
    fun init(flag: Boolean) {
        var i: Int
        var a: Int
        var b: Int
        var c: Int
        var d: Int
        var e: Int
        var f: Int
        var g: Int
        var h: Int
        h = RATIO
        g = h
        f = g
        e = f
        d = e
        c = d
        b = c
        a = b
        i = 0
        while (i < 4) {
            // Mixing operations for initialization.
            a = a xor (b shl 11)
            d += a
            b += c
            b = b xor (c ushr 2)
            e += b
            c += d
            c = c xor (d shl 8)
            f += c
            d += e
            d = d xor (e ushr 16)
            g += d
            e += f
            e = e xor (f shl 10)
            h += e
            f += g
            f = f xor (g ushr 4)
            a += f
            g += h
            g = g xor (h shl 8)
            b += g
            h += a
            h = h xor (a ushr 9)
            c += h
            a += b
            ++i
        }
        // Further memory setup with mixing.
        i = 0
        while (i < SIZE) {
            if (flag) {
                a += results[i]
                b += results[i + 1]
                c += results[i + 2]
                d += results[i + 3]
                e += results[i + 4]
                f += results[i + 5]
                g += results[i + 6]
                h += results[i + 7]
            }
            a = a xor (b shl 11)
            d += a
            b += c
            b = b xor (c ushr 2)
            e += b
            c += d
            c = c xor (d shl 8)
            f += c
            d += e
            d = d xor (e ushr 16)
            g += d
            e += f
            e = e xor (f shl 10)
            h += e
            f += g
            f = f xor (g ushr 4)
            a += f
            g += h
            g = g xor (h shl 8)
            b += g
            h += a
            h = h xor (a ushr 9)
            c += h
            a += b
            memory[i] = a
            memory[i + 1] = b
            memory[i + 2] = c
            memory[i + 3] = d
            memory[i + 4] = e
            memory[i + 5] = f
            memory[i + 6] = g
            memory[i + 7] = h
            i += 8
        }
        if (flag) {
            // Final pass to complete the initialization.
            i = 0
            while (i < SIZE) {
                a += memory[i]
                b += memory[i + 1]
                c += memory[i + 2]
                d += memory[i + 3]
                e += memory[i + 4]
                f += memory[i + 5]
                g += memory[i + 6]
                h += memory[i + 7]
                a = a xor (b shl 11)
                d += a
                b += c
                b = b xor (c ushr 2)
                e += b
                c += d
                c = c xor (d shl 8)
                f += c
                d += e
                d = d xor (e ushr 16)
                g += d
                e += f
                e = e xor (f shl 10)
                h += e
                f += g
                f = f xor (g ushr 4)
                a += f
                g += h
                g = g xor (h shl 8)
                b += g
                h += a
                h = h xor (a ushr 9)
                c += h
                a += b
                memory[i] = a
                memory[i + 1] = b
                memory[i + 2] = c
                memory[i + 3] = d
                memory[i + 4] = e
                memory[i + 5] = f
                memory[i + 6] = g
                memory[i + 7] = h
                i += 8
            }
        }
        // Final pass to generate results.
        isaac()
        count = SIZE
    }

    companion object {
        /**
         * The constant RATIO used in the ISAAC algorithm for generating random numbers.
         */
        const val RATIO: Int = -0x61c88647

        /**
         * The constant SIZE_LOG represents the logarithmic size of the internal memory.
         */
        const val SIZE_LOG: Int = 8

        /**
         * The constant SIZE represents the size of the internal memory, which is 2^SIZE_LOG.
         */
        const val SIZE: Int = 1 shl SIZE_LOG

        /**
         * The constant MASK used in the ISAAC algorithm for masking the memory indices.
         */
        const val MASK: Int = (SIZE - 1) shl 2
    }
}
